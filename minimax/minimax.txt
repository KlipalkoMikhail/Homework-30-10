// Циклический сдвиг массива вправо

#include <stdio.h>
#define N 2000

// 112 Клипалко Михаил Михайлович

int minimax(double number[], int count, double *max, double *min); // через адресный тип получим значение минимума и максимума
int main(void)
{
    double max = 0;
    double min = 0;
    char filename[120];
    double number[N]; // массив на N чисел
    int count = 0; // счетчик чисел

    printf("Shifter of the sequence\n");
    printf("Enter the file name: ");
    scanf("%s", filename);

    FILE * file = fopen(filename, "r");
    if(!file)
    {
        printf("File is not existing\n");
        return -1;
    }
    else
    {
        printf("File has been opened\n");
    }

    printf("Sequence:\n");
    while (fscanf(file, "%lf", &number[count]) == 1) // записываем числа в массив
    {
        printf("%lf ", number[count]); // выводим последовательность на экран
        count++;
        if ( count > N )
        {
            printf("File has too many numbers, last number of the sequence is %lf\n", number[count - 1]); // слишком много чисел в файле
            break;
        }
    }
    if (count == 0)
    {
        printf("ERROR: File is empty\n"); // защита от пустого файла
        return -1;
    }
    if (feof(file) == 0) // защита от некорректных символов в последовательности
    {
        printf(" ERROR: File has invalid numbers\n");
        return -1;
    }

    printf("\n");
    printf("\n");

    minimax(number, count, &max, &min);

    printf("MAX: %g\n", max);
    printf("MIN: %g\n", min);

    return 0;
}

// 112 Клипалко Михаил Михайлович

int minimax(double number[], int count, double *max, double *min)
{

    for (int i = 0; i < count; i++) // проверка на мин/макс
    {
        if (*max <= number[i]) // сравнение максимума с числом из массива
        {
            *max = number[i];
        }
        if (*min >= number[i]) // сравнение минимума с числом из массива
        {
            *min = number[i];
        }
    }

    return 0;
}